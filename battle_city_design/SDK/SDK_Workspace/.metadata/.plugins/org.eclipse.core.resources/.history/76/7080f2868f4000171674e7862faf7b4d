
#include "battle_city.h"
#include "map.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xio.h"

/*
* GENERATED BY BC_MEM_PACKER
* DATE: Wed Jul 08 21:00:48 2015
*/

// ***** 16x16 IMAGES *****

#define IMG_16x16_cigle			0x063F
#define IMG_16x16_coin			0x063F
#define IMG_16x16_crno			0x063F
#define IMG_16x16_enemi1		0x0EFF
#define IMG_16x16_mario			0x04FF
#define IMG_16x16_plavacigla	0x063F
#define IMG_16x16_muva_skupljena	0x0EFF
#define IMG_16x16_muva_rasirena		0x0EBF


// ***** MAP *****

#define MAP_BASE_ADDRESS			0x103F


#define MAP_X							0
#define MAP_X2							640
#define MAP_Y							4
#define MAP_W							64
#define MAP_H							56

#define REGS_BASE_ADDRESS               ( MAP_BASE_ADDRESS + MAP_WIDTH * MAP_HEIGHT )



#define BTN_DOWN( b )                   ( !( b & 0x01 ) )
#define BTN_UP( b )                     ( !( b & 0x10 ) )
#define BTN_LEFT( b )                   ( !( b & 0x02 ) )
#define BTN_RIGHT( b )                  ( !( b & 0x08 ) )
#define BTN_SHOOT( b )                  ( !( b & 0x04 ) )

#define TANK1_REG_L                     8
#define TANK1_REG_H                     9
#define TANK_AI_REG_L                   4
#define TANK_AI_REG_H                   5
#define TANK_AI_REG_L2                  6
#define TANK_AI_REG_H2                  7
#define TANK_AI_REG_L3                  2
#define TANK_AI_REG_H3                  3
#define TANK_AI_REG_L4                  10
#define TANK_AI_REG_H4                  11
#define TANK_AI_REG_L5                  12
#define TANK_AI_REG_H5                  13
#define TANK_AI_REG_L6                  14
#define TANK_AI_REG_H6                  15
#define TANK_AI_REG_L7                  16
#define TANK_AI_REG_H7                  17
#define BASE_REG_L						0
#define BASE_REG_H	                    1
#define BROJ_MUVA						3

int  prvi1 = 1;
int	 prvi2 = 1;
int  prvi3 = 1;


int broj_muva = BROJ_MUVA;
int brojac1 = 0;
int i ;
int y =450;


typedef enum {
    b_false,
    b_true
} bool_t;

typedef enum {
    DIR_LEFT,
    DIR_RIGHT,


} direction_t;

typedef struct {
    unsigned int    x;
    unsigned int    y;
    direction_t dir;
    unsigned int    type;

    bool_t          destroyed;


    unsigned int	reg_l;
    unsigned int	reg_h;
} characters;

characters mario = {
    320,	                        // x
    450, 		                     // y
    DIR_RIGHT,              		// dir
    IMG_16x16_mario,  			// type

    b_false,                		// destroyed

    TANK1_REG_L,            		// reg_l
    TANK1_REG_H             		// reg_h
};


characters enemie1 = {
	300,						// x
    50,						// y
    DIR_LEFT,              		// dir
    IMG_16x16_enemi1,  		// type

    b_false,                		// destroyed

    TANK_AI_REG_L,            		// reg_l
    TANK_AI_REG_H             		// reg_h
};

characters enemie2 = {
	320,						// x
    50,						// y
    DIR_LEFT,              		// dir
    IMG_16x16_enemi1,  		// type

    b_false,                		// destroyed

    TANK_AI_REG_L,            		// reg_l
    TANK_AI_REG_H             		// reg_h
};



characters enemie3  = {
    280,						// x
    50,						// y
    DIR_LEFT,              		// dir
    IMG_16x16_enemi1,  		// type

    b_false,                		// destroyed

    TANK_AI_REG_L4,            		// reg_l
    TANK_AI_REG_H4             		// reg_h
};

characters metak = {
	100,						// x
    100,						// y
    DIR_LEFT,              		// dir
    IMG_16x16_enemi1,  		// type

    b_false,                		// destroyed

    TANK_AI_REG_L2,            		// reg_l
    TANK_AI_REG_H2             		// reg_h
};




bool_t puca = b_false;
characters muve[BROJ_MUVA];

unsigned int rand_lfsr113( void )
{
	static unsigned int z1 = 12345, z2 = 12345 ;
	unsigned int b;

	b  = ( ( z1 << 6 ) ^ z1 ) >> 13;
	z1 = ( ( z1 & 4294967294U ) << 18 ) ^ b;
	b  = ( ( z2 << 2 ) ^ z2 ) >> 27;
	z2 = ( ( z2 & 4294967288U ) << 2) ^ b;


	return ( z1 ^ z2 );
}

static void chhar_spawn( characters * chhar )
{
	Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_l ),  (unsigned int)0x8F000000  | (unsigned int)chhar->type );
	Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + chhar->reg_h ),  (chhar->y << 16) | chhar->x );
}

static void map_update( map_entry_t * map )
{
    unsigned int i;

    for( i = 0; i < MAP_WIDTH * MAP_HEIGHT; i++ ) {
        if( map[ i ].update ) {
            map[ i ].update = 0;

            Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( MAP_BASE_ADDRESS + i ), ( (unsigned int)map[ i ].z << 24 ) | ( (unsigned int)map[ i ].rot << 16 ) | (unsigned int)map[ i ].ptr );
        }
    }
}

static void map_reset( map_entry_t * map )
{
    unsigned int i;

    for( i = 0; i < MAP_WIDTH * MAP_HEIGHT; i++ ) {
        Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( MAP_BASE_ADDRESS + i ), ( (unsigned int)map[ i ].z << 24 ) | ( (unsigned int)map[ i ].rot << 16 ) | (unsigned int)map[ i ].ptr );
    }

    for( i = 0; i <= 20; i += 2 ) {
    	Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + i ), (unsigned int)0x0F000000 );
    }
}


static void coin_destroy( characters * coin,unsigned int x, unsigned int y){
	coin->destroyed = b_true;

	Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + coin->reg_l ), (unsigned int)0x8F000000  | IMG_16x16_crno );
	Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + coin->reg_h ), ( coin>y << 16 ) | coin->x );

}


static bool_t mario_move( map_entry_t * map, characters * tank, direction_t dir)
{
		unsigned int    x;
	    unsigned int    y;


	    map_entry_t *   tl;
	    map_entry_t *   tc;
	    map_entry_t *   tr;
	    map_entry_t *   cl;
		map_entry_t *   cc;
		map_entry_t *   cr;
		map_entry_t *   bl;
		map_entry_t *   bc;
		map_entry_t *   br;



	    if( tank->x > (( MAP_X + MAP_W ) * 16 - 16 ) ||
	        tank->y > ( MAP_Y + MAP_H ) * 16 - 16 ) {
	        return b_false;
	    }

	    x = tank->x;
	    y = tank->y;

	    // Make sure that coordinates will stay within map boundaries after moving.
	    if( dir == DIR_LEFT ) {
	        if( x >  24  )
	        	x--;
	    } else if( dir == DIR_RIGHT ) {
	        if( x <   600 )
	        	x++;
	    }

	    if(tank->x == 454 && tank->y == 304 ){
	    	if(prvi1 = 1){
	    		coin_destroy(&coin1,x,y);
	    		map_update( map1 );
	    		prvi1 = 0;
	    	}
	    }else if (tank->x == 469 && tank->y == 304 ){
	    	if(prvi2 == 1){
	    		coin_destroy(&coin2,x,y);
	    		map_update( map1 );
	    		prvi2 = 0;
	    	}

	    }else if(tank->x == 484 && tank->y == 304 ){
	    	if(prvi3 = 1){
	    		coin_destroy(&coin3,x,y);
	    		map_update( map1 );
	    		prvi3 = 0;
	    	}

	    }




	    tl = &map[ ( y / 16 ) * MAP_WIDTH + ( x / 16 ) ];
		tc = &map[ ( y / 16 ) * MAP_WIDTH + ( ( x + 7 ) / 16 ) ];
		tr = &map[ ( y / 16 ) * MAP_WIDTH + ( ( x + 15 ) / 16 ) ];
		cl = &map[ ( ( y + 7 ) / 16 ) * MAP_WIDTH + ( x / 16 ) ];
		cc = &map[ ( ( y + 7 ) / 16 ) * MAP_WIDTH + ( ( x + 7 ) / 16 ) ];
		cr = &map[ ( ( y + 7 ) / 16 ) * MAP_WIDTH + ( ( x + 15 ) / 16 ) ];
		bl = &map[ ( ( y + 15 ) / 16 ) * MAP_WIDTH + ( x / 16 ) ];
		bc = &map[ ( ( y + 15 ) / 16 ) * MAP_WIDTH + ( ( x + 7 ) / 16 ) ];
		br = &map[ ( ( y + 15 ) / 16 ) * MAP_WIDTH + ( ( x + 15 ) / 16 ) ];

	    if( tank->x != x || tank->y != y ) {
	        // Tank can move if water, iron or brick wall isn't ahead.
	        if( tl->ptr != IMG_16x16_plavacigla && tl->ptr != IMG_16x16_cigle && tl->ptr != IMG_16x16_enemi1 &&
				tc->ptr != IMG_16x16_plavacigla && tc->ptr != IMG_16x16_cigle && tc->ptr != IMG_16x16_enemi1 &&
				tr->ptr != IMG_16x16_plavacigla && tr->ptr != IMG_16x16_cigle && tr->ptr != IMG_16x16_enemi1 &&
				cl->ptr != IMG_16x16_plavacigla && cl->ptr != IMG_16x16_cigle && cl->ptr != IMG_16x16_enemi1 &&
				cc->ptr != IMG_16x16_plavacigla && cc->ptr != IMG_16x16_cigle && cc->ptr != IMG_16x16_enemi1 &&
				cr->ptr != IMG_16x16_plavacigla && cr->ptr != IMG_16x16_cigle && cr->ptr != IMG_16x16_enemi1 &&
	        	bl->ptr != IMG_16x16_plavacigla && bl->ptr != IMG_16x16_cigle && bl->ptr != IMG_16x16_enemi1 &&
	        	bc->ptr != IMG_16x16_plavacigla && bc->ptr != IMG_16x16_cigle && bc->ptr != IMG_16x16_enemi1 &&
	        	br->ptr != IMG_16x16_plavacigla && br->ptr != IMG_16x16_cigle && br->ptr != IMG_16x16_enemi1 ) {

	            tank->x = x;
	            tank->y = y;

	            if( tank->dir != dir ) {
	                tank->dir = dir;

	                Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + tank->reg_l ), (unsigned int)0x8F000000  | tank->type );
	            }

	            Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + tank->reg_h ), ( tank->y << 16 ) | tank->x );

	            return b_true;

	        } /*else if( bc->ptr == IMG_16x16_crno){

	        	 tank->x = x;
	        	 tank->y = y+65;

	        	 if( tank->dir != dir ) {
	        		 tank->dir = dir;

	        		 Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + tank->reg_l ), (unsigned int)0x8F000000  | tank->type );
	        	}

	        	 	 Xil_Out32( XPAR_BATTLE_CITY_PERIPH_0_BASEADDR + 4 * ( REGS_BASE_ADDRESS + tank->reg_h ), ( tank->y << 16 ) | tank->x );

	        		 return b_true;

	        }*/


	    }

	return b_false;
}

static void process_ai( characters * tank, unsigned int * ai_dir )
{ /*int t brojac = 0;
	unsigned int	tmp_dir;
	bool_t			turn;
	unsigned int	i;


	if( turn == b_true ) {
		do {
			while( tmp_dir == *ai_dir ) {
				tmp_dir = rand_lfsr113( ) % 2;
			}

			*ai_dir = tmp_dir;

		} while( mario_( map1, &enemie, *ai_dir) == b_false );
	} else {
		while( mario_move( map1, &enemie, *ai_dir ) == b_false ) {
			while( tmp_dir == *ai_dir ) {
				tmp_dir = rand_lfsr113( ) % 2;
			}

			*ai_dir = tmp_dir;
		}
	}

	i = 0;


	if( *ai_dir == DIR_RIGHT ) {
		while( tank->x / 8 + i < (MAP_X + MAP_W)/2 ) {
			if( map1[ ( tank->y / 8 + i ) * MAP_WIDTH + tank->x / 8 ].ptr == IMG_16x16_enemi1)
				{
					break;
				}
			i++;
		}

	} else if( *ai_dir == DIR_LEFT ) {
		while( tank->x / 8 + i < (MAP_X + MAP_W)/2 ) {
			if( map1[ ( tank->y / 8 + i ) * MAP_WIDTH + tank->x / 8 ].ptr == IMG_16x16_enemi1)
			{
		      break;
		    }
		i++;

		}
	}*/
}


void muva_leti(characters * muva){

	if (muva->destroyed == b_false){

		if(brojac1 == 0){
			muva->type = IMG_16x16_muva_rasirena;
			chhar_spawn(muva);

			}

		if(brojac1 == 150){
			muva->type = IMG_16x16_muva_skupljena;
			chhar_spawn(muva);
		}

	 if(brojac1 == 300){


		brojac1 = -1;
	 }
	 brojac1++;




	}

}




void battle_shoot(characters * brod , characters * metak){
	int x = brod -> x;
	int type = metak -> type;
	if(y == 450)
	metak->x = x;

	metak->y = y;
	y = y - 4;

	if(y == -2){
		puca = b_false;
		y = 450;
	}


		chhar_spawn(metak);

		for(i = 0 ; i < broj_muva ; i++){
			if( metak->x >  muve[i].x - 10 && metak->x < muve[i].x + 10 && metak->y == muve[i].y){
				coin_destroy(&muve[i],x,metak->y);

			}

		}

	}



void fill_enemie(void) {

	muve[0] = enemie3;
	muve[1] = enemie2;
	muve[2] = enemie1;


}



void battle_city( void )
{

	unsigned int buttons, tmpBtn = 0, tmpUp = 0;
	int i,change = 0;

	map_reset( map1 );
	fill_enemie();


	chhar_spawn(&mario);

		while( 1 ) {
			for(i = 0 ; i < 30000; i++){}


			muva_leti(&muve[1]);
			muva_leti(&muve[0]);
			muva_leti(&muve[2]);

    	    buttons = XIo_In32( XPAR_IO_PERIPH_BASEADDR );

			if( BTN_LEFT( buttons ) ) {
				mario_move( map1, &mario, DIR_LEFT );
				tmpBtn = 1;
				tmpUp = 0;
			} else if( BTN_RIGHT( buttons ) ) {
				mario_move( map1, &mario, DIR_RIGHT );
				tmpBtn = 0;
				tmpUp = 0;
			} else if( BTN_UP( buttons ) ) {
				puca = b_true;

			} else if( BTN_DOWN( buttons ) ) {

				tmpUp = 0;
			}

			if(puca == b_true){
				battle_shoot(&mario,&metak);




			}

		//process_ai( &enemie, DIR_LEFT );
		//for(i = 0; i < 300000; i++){}


        map_update( map1 );

    }
}
